### 动态规划

拆分子问题，记录子问题结果，推导出后续问题的结果

#### 青蛙跳台阶问题
```markdown
一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法。
```
##### 递归方法
  从后向前推断：
  青蛙最后一次跳，有可能是跳了1级台阶，也可能是2级台阶，只有这两种可能：
  - 如果青蛙最后一次跳台阶的时候是跳了1级台阶，那么f(10) = f(9)
  - 如果青蛙最后一次跳台阶的时候跳了2级台阶，那么f(10) = f(8)
  
  所以f(10) = f(9) + f(8)
  同理可以推： f(9) = f(8) + f(7), f(8) = f(7) + f(6)
  同时 f(9) = f(8) + f(7) = (f(7)+f(6)) + f(7) = ((f(6)+f(5)) + f(6)) + (f(6)+f(5))
  最后f(1) = 1, f(2) = 2
  然后根据f(1), f(2), 不断求出f(3), f(4)...直到f(10)
  整个程序的计算过程先将f(10)不断拆解，拆解到f(1), f(2), 不能拆解之后，再根据已知的f(1), f(2)的值，计算f(3)到f(10)的值。
 
##### 优化
  计算时， f(5) = f(4) + f(3), 先求 f(4) = f(3) + f(2) = f(2) + f(1) + f(2)， 再求f(3) = f(2) + f(1)
  会发现，f(3)计算了两次，单独求f(3)时计算一次，计算f(4)时又计算了一次，如果f(n)中的n是一个很大的数，那么过程中的f(3<=i<=n-1)需要重复计算的次数将非常多。
  因此，可以使用一个数组或字典作为备忘录，用于记录f(i)的值。  计算时先看备忘录中是否包含了f(i)的值，如果有了则从备忘录直接取值，备忘录没有再计算。
  这种算作带备忘录的递归，不是算是动态规划
  
##### 动态规划
  特点：**自底向上**
  根据已知条件： f(n) = f(n-1) + f(n-2), f(1) = 1, f(2) = 2
  计算f(3) = f(2) + f(1) = 2 + 1 = 3, 此是f(3)的值是已知的，再根据f(3)已知，f(2)已知，求f(4)。这样通过一次循环就可以求出f(n)的值，算法复杂度为O(n).
  

  

